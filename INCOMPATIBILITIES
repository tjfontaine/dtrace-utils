This file documents known incompatibilities between Linux and Solaris dtrace,
together with the difficulty of overcoming them, and the likelihood that they
will be overcome.

Missing providers
-----------------
Difficulty: Medium
Likelihood: High

A number of providers are missing, including fbt and net.


No userspace tracing
--------------------
Difficulty: Medium
Likelihood: High

Userspace tracing is simply not implemented yet.


No userspace traceback in ustack()
----------------------------------
Difficulty: Medium
Likelihood: High

ustack() and related actions which should print out symbol names in userspace
tracebacks currently print out addresses only.  This is due to a not-yet-
fixed Solaris/Linux incompatibility, and will be fixed.


No traceback for local functions
--------------------------------
Difficulty: Medium
Likelihood: Medium

However, even when ustack() is fixed, the userspace traceback will not be up to
the standards you may expect from Solaris, because Linux has no analogue of the
Solaris local dynamic symbol table, so static symbols and those hidden via
-fvisibility=hidden will not be named in the traceback.

There are two options to fix this: firstly, we could use DWARF to look up the
symbols, as gdb does: alternatively, we could implement a local dynamic symbol
table, and alter the compiler to handle it.  The former solution provides
theoretically complete compatibility with existing binaries, but has the problem
that DWARF debugging info is so voluminous that it would make dtrace terribly
slow and memory-hungry (as slow and memory-hungry as gdb is when tracing a large
program).  Worse yet, because DWARF debugging info is so large, it is rarely
installed, so the output would be incomplete anyway.

So this may instead need to be fixed by introducing support for .SUNW_ldynsym in
the Oracle Enterprise Linux toolchain.  Binaries compiled with other toolchains
won't get full tracebacks, but we can live with that.



Tiny variations in behaviour of dtraced processes immediately after startup
---------------------------------------------------------------------------
Difficulty: High
Likelihood: Low

Because Linux dtrace depends on ptrace() at attachment time, a very few tiny
behavioural changes can be expected in dtraced processes in the instant dtrace
begins attaching to them.  Notably, a process that has just been created or
grabbed by dtrace may lose signals sent to it and will not be debuggable until
dtrace has set it going.  This problem does not exist for processes that are
already being debugged.

It is highly unlikely that anyone will ever notice this.


Kernel probe names differ
-------------------------
Difficulty: Very high
Likelihood: Nil

Kernel probe names largely differ between Solaris and Linux. This is no
different from other dtrace platforms, for the same reason, and is just as
unlikely to be fixed. The kernels are different, with differently-named
functions in, the probe names are derived from the names of the functions, thus
the probes are different.



-Xs semantics differ
--------------------
Difficulty: High
Likelihood: Nil

GNU cpp does not implement the various conformance levels supported by Solaris
cpp: instead, you in practice have a choice between a traditional cpp and a
fully standards-conformant one with __STDC__=1. The other variants (with
__STDC__=0 but ISO C rules, and turning various header K&R compatibility
extensions off and on) only exist because of Solaris's commitment to backward-
compatibility-to-a-fault in the C library headers. glibc does not have this
commitment, so most of these options make no sense.

In Linux dtrace, -Xa, -Xc and -Xt all set __STDC__=1; -Xs unsets it and sets
-traditional.
