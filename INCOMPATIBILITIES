This file documents known incompatibilities between Linux and Solaris dtrace,
together with the difficulty of overcoming them, and the likelihood that they
will be overcome.

Missing providers
-----------------
Difficulty: Medium
Likelihood: High

A number of providers are missing, including fbt and net.


No userspace tracing
--------------------
Difficulty: Medium
Likelihood: High

Userspace tracing is simply not implemented yet.


No userspace traceback in ustack()
----------------------------------
Difficulty: Medium
Likelihood: High

ustack() and related actions which should print out symbol names in userspace
tracebacks currently print out addresses only.  This is due to a not-yet-
fixed Solaris/Linux incompatibility, and will be fixed.


No traceback for local functions
--------------------------------
Difficulty: Medium
Likelihood: Medium

However, even when ustack() is fixed, the userspace traceback will not be up to
the standards you may expect from Solaris, because Linux has no analogue of the
Solaris local dynamic symbol table, so static symbols and those hidden via
-fvisibility=hidden will not be named in the traceback.

There are two options to fix this: firstly, we could use DWARF to look up the
symbols, as gdb does: alternatively, we could implement a local dynamic symbol
table, and alter the compiler to handle it.  The former solution provides
theoretically complete compatibility with existing binaries, but has the problem
that DWARF debugging info is so voluminous that it would make dtrace terribly
slow and memory-hungry (as slow and memory-hungry as gdb is when tracing a large
program).  Worse yet, because DWARF debugging info is so large, it is rarely
installed, so the output would be incomplete anyway.

So this may instead need to be fixed by introducing support for .SUNW_ldynsym in
the Oracle Enterprise Linux toolchain.  Binaries compiled with other toolchains
won't get full tracebacks, but we can live with that.


No projects, zones, tasks, contracts, or message queues
-------------------------------------------------------
Difficulty: High
Likelihood: Low (unless kernel support is added)

The Linux kernel does not implement projects, zones, tasks, contracts, or
message queues: all corresponding identifiers are gone, and the msgdsize() and
msgsize() subroutines no longer work.  (It would be possible to keep them but
mark them reserved, but the result would be the same: D scripts that use these
identifiers would fail to compile, or fail to work as expected.)


Tiny variations in behaviour of dtraced processes immediately after startup
---------------------------------------------------------------------------
Difficulty: High
Likelihood: Low

Because Linux dtrace depends on ptrace() at attachment time, a very few tiny
behavioural changes can be expected in dtraced processes in the instant dtrace
begins attaching to them.  Notably, a process that has just been created or
grabbed by dtrace may lose signals sent to it and will not be debuggable until
dtrace has set it going.  This problem does not exist for processes that are
already being debugged.

It is highly unlikely that anyone will ever notice this.


Kernel probe names differ
-------------------------
Difficulty: Very high
Likelihood: Nil

Kernel probe names largely differ between Solaris and Linux. This is no
different from other dtrace platforms, for the same reason, and is just as
unlikely to be fixed. The kernels are different, with differently-named
functions in, the probe names are derived from the names of the functions, thus
the probes are different.


-Xs semantics differ
--------------------
Difficulty: High
Likelihood: Nil

GNU cpp does not implement the various conformance levels supported by Solaris
cpp: instead, you in practice have a choice between a traditional cpp and a
fully standards-conformant one with __STDC__=1. The other variants (with
__STDC__=0 but ISO C rules, and turning various header K&R compatibility
extensions off and on) only exist because of Solaris's commitment to backward-
compatibility-to-a-fault in the C library headers. glibc does not have this
commitment, so most of these options make no sense.

In Linux dtrace, -Xa, -Xc and -Xt all set __STDC__=1; -Xs unsets it and sets
-traditional.


Library differences
-------------------
Difficulty: Very high
Likelihood: Nil

For consumers of libdtrace, <dtrace.h> has various differences.  These reflect
intrinsic Solaris/Linux differences which will not be fixed.

Currently:

dtrace_objinfo.dto_flags has lost the DTRACE_OBJ_F_PRIMARY value: the Linux
kernel has no concept of 'primary modules'.  As a consequence, the 'primary'
linkmode option is gone.  dtrace_objinfo.dto_file for a kernel module will
be the null string before that module is loaded.

Because modules in the Linux kernel may have many discontiguous regions of text
and data interspersed with other modules, dtrace_objinfo no longer has
dto_text_va, dto_data_va, dto_bss_va or the corresponding _size members;
instead, dto_text_addrs and dto_data_addrs and corresponding _size members
provide access to sorted arrays of dtrace_addr_range_t structures representing
all text and data ranges in the object: these arrays are freed at
dt_module_destroy() time.  A new function dtrace_addr_range_cmp() permits
bsearch()ing of these arrays.  (We no longer distinguish between initialized
data and bss sections.)

The dtrace_syminfo_t type populated by dtrace_lookup_by_name() and
dtrace_lookup_by_addr() no longer guarantees population of its dts_id member:
for kernel symbols, it will always be zero.  In future a further API change may
require the caller to free the dts_name member: this will be signalled by its no
longer being declared const.

The GElf_Sym parameter populated by dtrace_lookup_by_name() and
dtrace_lookup_by_addr() no longer guarantees population of its st_name or
st_other fields, and the only thing guaranteed about st_shndx is SHN_UNDEF
versus !SHN_UNDEF (there is no guarantee that it will correspond to an actual
ELF section).  If you want the symbol name, you should use the
dtrace_syminfo.dts_name instead.  There is no guaranteed replacement for
st_other.

dtrace_update() now returns an error value, like dtrace_go() and dtrace_stop().

There is a new dtrace_debug_set_dump_sig() function, which sets the signal (by
default SIGUSR1); when DTRACE_DEBUG=signal is set in the environment at startup,
debugging output then goes into a ring buffer which is dumped to stderr when
this signal is sent.  If set to 0, this debugging facility is disabled.  (The
buffer is also dumped on dtrace_close() and on disconnection from traced
processes.)

The ring buffer is 100Mb long, by default: the optional DTRACE_DEBUG_BUF_SIZE
environment variable gives a new size, in Mb.

Incompatible behaviour for specific probes
------------------------------------------
proc:::signal-discard
	If a signal that is sent as event notification for a POSIX timer
	expiration should be discarded, no signal-discard probe is fired.
	The reason for this behaviour is that SDT probes do not work in
	IRQ context.
