0.4.4
-----

New options:

 - -xcppargs: Additional arguments to pass to the preprocessor when run over D
    scripts by DTrace.

Bugfixes:

 - The DOF ELF object generated by dtrace -G no longer requires an executable
   stack.

0.4.3
-----

Bugfixes:

 - Several memory-allocation, underrun and overrun bugs in process handling
   were fixed.  With sufficient ingenuity these may be exploitable by local
   users who can craft and run unusual ELF executables and arrange for dtrace
   to attach to them.

0.4.2
-----

Bugfixes:

 - Kill -9'ing a running dtrace will no longer leave breakpoints outstanding in
   processes with no controlling terminal that were grabbed as a side effect of
   ustack(), usym(), uaddr() or umod); as a side effect, symbol resolution will
   be less accurate for such processes.  Grabbing a process with no controlling
   terminal via dtrace -p restores full symbol resolution accuracy for these
   processes, at the cost of dropping breakpoints in them again.  Processes with
   a controlling terminal are still treated as in prior releases.

 - ustack(), usym(), uaddr() and umod() of multithreaded processes no longer
   crashes the system, oopses the kernel, hangs the process being probed,
   crashes dtrace(1) itself, or runs dtrace or the system as a whole out of
   filehandles.

 - Interrupting dtrace with a SIGINT while monitored processes are dying
   simultaneously now consistently stops it rather than hanging forever.

 - dtrace's symbol-resolution paths are armoured against various problems which
   could occur when processes died while lookups were underway.

 - pid and ppid are now correctly derived for multithreaded processes, pointing
   to the POSIX pid and parent respectively rather than the thread and thread
   group leader.

 - Resolving kernel symbols located at the start of modules will no longer
   cause dtrace userspace to dereference uninitialized memory as a pointer.

0.4.1
-----

New features:

 - New development tools showUSDT (for dumping of DOF sections) and
   ctf_module_dump (for dumping of CTF in kernel modules).  (The former tool is
   an example only, and is installed in the documentation directory.)

 - DTrace now automatically modprobes for dtrace.ko if needed, and yum installs
   it if it is not found on the system.  Provider modules are not automatically
   modprobed, but running (for example) dtrace -l is now a good way to make sure
   that the modules are present on the system so you can modprobe them.

Bugfixes:

 - A lexer bug was fixed which caused spurious errors if D scripts contained a
   #pragma or comment at intervals of 8192 characters, and prevented the use
   of scripts >16KiB entirely.
   [Introduced in the original Linux port]

 - A variety of memory leaks and uninitialized memory reads are fixed.

 - A bug whereby breakpoints could be left outstanding in a process if dtrace
   was interrupted with an ordinary SIGINT at just the wrong instant is fixed.
   [Introduced in DTrace 0.4.0.]

 - The visibility of .SUNW_dof sections was wrong.
   [Introduced in DTrace 0.4.0.]

 - Fix devinfo_t's dev_statname and dev_pathname for cases where the
   device does not have partitions.
   [Introduced in DTrace 0.4.0.]

 - drti.o, which contributes a constructor to programs and shared libraries
   that contain DOF, now has lower overhead when DTrace is not running,
   emits its errors to stdout, not stderr, and opens its files with O_CLOEXEC.
   [Introduced in DTrace 0.4.0.]

0.4
---

New features:

 - Symbol lookup now works: stack() and ustack() now print symbols, as does &.
   ustack() can look up symbols in libraries loaded with dlopen() and dlmopen()
   as well as via DT_NEEDED.  Symbol lookup of global symbols in userspace
   processes respects symbol interposition and all other symbol-ordering
   trickery.  Some of the machinery involved in this only works with programs
   running against specific versions of the GNU C Library.  (It will always work
   with the version of glibc shipped with OEL, and falls back to a simpler
   approach which does not support symbol interposition or dlmopen() if it
   appears an incompatible glibc is in use).

   This depends on new machinery in the kernel, notably waitfd()s and
   PTRACE_GETMAPFD, so will not work with earlier DTrace kernels.

 - USDT support: see the dtrace-module NEWS.  A new header file (sys/sdt.h) is
   installed in support of USDT.

 - -xevaltime={preinit, postinit, main} now work, with a few caveats:

   - postinit (the default) is equivalent to main.

   - On statically linked binaries, preinit is equivalent to exec, and may
     not skip ld.so initialization (which can happen after main() on such
     binaries).

   - On stripped, statically linked binaries, postinit and main are equivalent
     to preinit, because we cannot look up the 'main' symbol when there is no
     symbol table.

 - DTrace options can now be set from environment variables named DTRACE_OPT_*.
   Example:

     export DTRACE_OPT_INCDIR=/usr/lib64/dtrace:/usr/include/sys

Changes to user-visible internals:

 - The ELF section in which CTF data is stored has changed from .dtrace_ctf to
   .ctf.

 - The storage representation of internal kernel symbols is improved, saving
   DTrace memory usage at startup by a megabyte or so.

 - The libdtrace public API header now names its arguments.  A few other
   libdtrace functions have changed prototype: see INCOMPATIBILITIES.

 - Two undocumented libproc environment variables from Solaris are removed,
   because the code whose behaviour they adjusted no longer exists:
   _LIBPROC_INCORE_ELF and _LIBPROC_NO_QSORT.

 - New low-overhead debugging machinery.  Exporting DTRACE_DEBUG=signal in the
   environment will emit debugging output only when DTrace is hit by a SIGUSR1,
   avoiding all printf() locking overhead until then.  This uses a ring buffer
   to stop debugging output, by default 100Mb in size, changeable via the
   DTRACE_DEBUG_BUF_SIZE variable (which takes a size in megabytes).

Bugfixes:

 - The -h and -G command-line options work.

 - Negative values passed to DTrace options that take only positive integers are
   correctly diagnosed as errors again.

Known bugs and limitations:

 - Presently, kill -9'ing a running dtrace can leave breakpoints outstanding in
   other processes, which may sooner or later kill them.  This will be fixed in
   due course (by avoiding the use of breakpoints in more cases).

0.3
---

New features:

 - CTF support.  This exposes all kernel types declared at the global scope to
   DTrace scripts (even those private to single files).  All global kernel
   variables not declared static are also available to the ` operator as
   external variables.

   The module for kernel-wide symbols is known as vmlinux, but genunix can
   still be used as a name for it to aid script portability.

   Kernel modules from a compatible kernel must be visible to DTrace for this
   feature to work, as must the kernel-provided file /proc/kallmodsyms.  DTrace
   will work with no kernel modules, with no visible /proc, or with a kernel
   whose modules do not contain type information, but no kernel types or
   variables will be available.  (See -xprocfspath and -xmodpath below.)

New dependencies:

 - DTrace now depends on libdtrace-ctf, a modified, GPLed port of the Solaris
   libctf type-storage library.  Despite its name it cannot read Solaris CTF
   files: the file formats are incompatible.

New options:

 - -xprocfspath: if set, specifies the path to /proc.  May be useful in chroots,
   though glibc and other things may break if /proc is moved to another
   location.

 - -xmodpath: if set, specifies the path to kernel modules, rather than looking
   in /lib/modules/$(uname -r).

Options removed:

 - The undocumented -xlinkmode=primary option is removed: it never worked in
   DTrace for Linux in any case.

Bugfixes:

 - The -c and -p command-line options work.

 - Lexer bugs causing aggressive and unnecessary reading of modules are fixed.
   As a result, when used with typo-free scripts, DTrace now starts much faster
   than ever it did on Solaris (often taking half the time or less).  You may
   find a few error messages have changed error text (though not error tag) as a
   result of this bugfix and the following one.

 - The SDT provider now describes its argument types to DTrace userspace.

 - Supported SDT probes in non-text segments

 - The types of many DTrace actions and variables are fixed to correspond to
   the Linux reality.

 - The set of available error numbers in errno.d is more complete.

 - DTrace libraries are installed to /usr/lib64 now, not /usr/lib.

 - Users of dtrace -C can now #include <sys/dtrace.h> without incident.

Changes to user-visible internals:

 - A new file /proc/kallmodsyms now exists, like /proc/kallsyms but giving
   object sizes and listing the module each kernel object would be part of
   were it built as a module, even if it is currently built in.

 - A new module dtrace_ctf.ko is pulled in whenever dtrace.ko is loaded.
   It is a container for type information.

 - The undocumented -B buffer-inspection command-line option no longer crashes
   DTrace.


0.2.5
-----

New features:

 - libdtrace is now a shared library, just as on OpenSolaris, with a very
   similar API.  No API or ABI compatibility guarantees are made regarding
   this library, at present.


0.2
---

New features:

 - The SDT provider is implemented, providing in-kernel static probes.  Some of
   the proc provider is implemented using this facility.

Bugfixes:

 - Syscall tracing of stub-based syscalls (such as fork, clone, exit, and
   sigreturn) now works.
 - Invalid memory accesses inside D scripts no longer cause oopses or panics.
 - Memory exhaustion inside D scripts no longer emits spurious oopses.
 - Several crash fixes.
 - Fixes to arithmetic inside aggregations, fixing quantize().
 - Improvements to the installed headers.


0.1
---

First release. Working components:

 - the entire D language, with the exception of parts that depend on
   symbol lookup or CTF

 - the syscall provider (with the exception of the clone probe, which
   is disabled)

 - the profile provider (with the exception of arbitrary-precision
   profile timers).

 - kernel stack tracebacks, but ustack() prints addresses only, no symbols

Major components not yet present include all the other providers, including sdt
usdt.
