0.6.0
-----

New features:

  - dtrace consumers (including dtrace(1)) can now grab themselves via -p,
    though symbol resolution is degraded when they do so because they
    cannot stop themselves.  (Previously, such grabs were suppressed but
    the code to do so was buggy and caused dtrace not to terminate if
    dtrace was asked to do a self-grab in conjunction with a -c of
    some other process, even once the other process had terminated.)

  - The DTRACE_PROBEn() macros used for USDT probes have been supplanted by a
    new DTRACE_PROBE() macro which works exactly the same except that you don't
    need to count the arguments any more.  The old numbered macros remain
    available for code that must be compiled with compilers that don't support
    __VA_ARGS__ comma elision (such as GCC when in c89/strict-ANSI mode).  This
    involves a new, installed, internal header, /usr/include/sys/sdt_internal.h.
    (See the dtrace-modules NEWS for a similar change on the modules side.)

  - D translators for the ip provider are now available.

Bugfixes:

  - Numerous dtrace -c/-p and USDT fixes on SPARC systems, with symptoms
    varying from a hanging dtrace and child process to a dtrace that
    runs out of file descriptors.

  - Fix memory and fd leaks when a process monitored with -c or -p exec()s
    frequently.

Changes to user-visible internals:

  - DTrace now uses /proc/$pid/map_files, where available.

0.5.4
-----

Workarounds:

  - Work around a bug in elfutils causing massive corruption of object files when
    dtrace -G is used.

0.5.3
-----

Crash fixes:

  - When dtrace(1) exited at the same instant as a process it had grabbed (e.g.
    for ustack()) terminated, it could deadlock or crash with an assertion
    failure or a segmentation fault.

0.5.2
-----

Crash fixes:

  - Programs containing USDT probes can crash at startup or dlopen() time if
    shared libraries are mapped into the top half of the address space.  This
    never happens on x86-64 but is common on SPARC64: dtrace -G should be
    rerun on programs on such platforms that contain USDT probes, to link in
    the fixed ELF constructor.

Performance improvements:

  - dtrace(1) no longer wastes time in a CPU-heavy busywaiting loop: previously,
    the sleeping code was mistakenly picking a time in the past to sleep to
    roughly half the time

Bugfixes:

  - dtrace -c and -p now work on SPARC64.

0.5.1
-----

Performance improvements:

  - dtrace(1) and libdtrace(1) startup speed is improved, both by avoiding a
    filesystem walk by using the modules.order file to locate available kernel
    modules, and by avoiding loading all kernel modules to resolve possible
    types when unqualified probe names that cannot possibly be C identifiers are
    seen (like 'tick-1sec').  When the disk cache is cold these changes speed up
    startup by on the order of 2x.

Changes to user-visible internals:

  - The DTRACE_DEBUG debugging option could intermingle debugging output in
    limited ways when multiple threads were emitting debugging at once.

0.5.0
-----

New architectures:

  - Linux on SPARC64 is supported.  Userspace tracing doesn't work yet.

New options:

  - -xuseruid: On non-systemd systems (such as OL6), specify the user ID of
    the first non-system user.  (The default will normally be appropriate.)
    Processes with uids below this, and which appear to truly be daemons, are
    only ptrace()d if explicitly specified via dtrace -p or -c.

  - -xsysslice: On systemd systems (such as OL7), specify the name of the
    system slice.  (The default will almost always be appropriate.)
    Processes in this slice or the root slice are considered crucial system
    daemons and only ptrace()d if explicitly specified, as above.

    The systemd/non-systemd determination is made dynamically, so you can
    switch init systems freely and everything should still work.

Changes to user-visible internals:

  - Translator support for the UEK4 4.1 kernel.

Bugfixes:

  - Symbol resolution in non-ptraceable processes is improved.

  - dtrace -p with an invalid PID now produces a sensible error message.

0.4.6
-----

New dependencies:

 - dtrace-utils-devel now always pulls in the corresponding version of
   dtrace-utils, rather than being satisfied with whatever version is
   installed.
   [Introduced in DTrace 0.3.0.]

 - The DTrace kernel header package was renamed dtrace-modules-shared-headers
   in dtrace-modules 0.4.4; dtrace-utils now follows this renaming.

New options:

 - dtrace -vV now reports information on the released version of dtrace, as well
   as the internal version-control ID of dtrace(1) and libdtrace(1).  (The last
   two should always be the same unless the installation is faulty.)

Bugfixes:

 - Processes that receive SIGTRAP in normal operation now work even when being
   dtraced for a ustack(), etc.  Previously, the SIGTRAP would be ignored.
   [Introduced -- intentionally -- in DTrace 0.4.5, though this case would have
    misbehaved in other ways since 0.4.0.]

 - DTrace no longer loses track of processes that exec() while DTrace is looking
   at their dynamic linker state.

 - DTrace no longer leaves breakpoints lying around in fork()ed processes, but
   properly detaches from them and removes its breakpoints.

 - DTrace no longer considers that it knows the state of the symbol table of
   processes it has since stopped monitoring.

 - DTrace no longer crashes multithreaded processes that do dlopen() /
   dlclose().
   [All introduced in DTrace 0.4.0.]

Library interface changes:

 - #including <dtrace.h> used to fail because of the absence of a
   Solaris-specific header we did not ship.  That header is no longer called
   for.

Changes to user-visible internals:

 - DTrace now loads D libraries (with translators, etc) from directories with a
   name that depends upon the running kernel, so can support multiple kernels
   with the same userspace package.

Known bugs:

 - Multithreaded processes under u{stack,sym,addr,mod}() which do dlopen() in
   threads other than the first may not have accurate symbol resolution for
   symbols introduced by such dlopen()s.

0.4.5
-----

New features:

 - Provider modules are now automatically loaded from /etc/dtrace-modules
   when DTrace initializes for the first time, at the same time as dtrace.ko.
   (Providers that do not come from the dtrace-modules package are not
   automatically 'yum install'ed.)

Bugfixes:

 - Fix intermittent dtrace crash on failure of initial grabs or creations of
   processes (via dtrace -p or -c, or via ustack(), usym(), uaddr(), or umod()).

 - Fix dtrace -S DIF subr names.
   [Introduced in DTrace 0.4.0.]

 - DTrace can now reliably monitor processes that undergo exec() and processes
   that are hit by stopping signals and later resumed.  (Previously, it would
   sometimes lose track of the victim process, sometimes kill it with a SIGTRAP,
   and sometimes crash itself.)  Numerous other subtle bugs and deadlocks in
   this area have been fixed as a side-effect.

 - Fix a sign-extension bug in breakpoint-instruction poking which could cause
   the monitored process to crash.
   [Introduced in DTrace 0.4.0.]

 - DTrace is now more resilient against changes to glibc: many places where
   non-ABI-guaranteed internals of glibc are relied upon now dynamically search
   for the correct field offsets, so are resilient against new fields appearing
   in glibc's internal structures, and against fields changing size.

Library interface changes:

 - The dtrace_proc_*() functions have changed the type they take (it is now a
   small structure passed by value).  See INCOMPATIBILITIES.

   There are still no binary-compatibility guarantees for libdtrace consumers.

Known bugs:

 - Processes under u{stack,sym,addr,mod}() cannot receive SIGTRAP.

 - Multithreaded processes under u{stack,sym,addr,mod}() which do dlopen() in
   threads other than the first may crash.

0.4.4
-----

New options:

 - -xcppargs: Additional arguments to pass to the preprocessor when run over D
    scripts by DTrace.

Bugfixes:

 - The DOF ELF object generated by dtrace -G no longer requires an executable
   stack.

0.4.3
-----

Bugfixes:

 - Several memory-allocation, underrun and overrun bugs in process handling
   were fixed.  With sufficient ingenuity these may be exploitable by local
   users who can craft and run unusual ELF executables and arrange for dtrace
   to attach to them.

0.4.2
-----

Bugfixes:

 - Kill -9'ing a running dtrace will no longer leave breakpoints outstanding in
   processes with no controlling terminal that were grabbed as a side effect of
   ustack(), usym(), uaddr() or umod); as a side effect, symbol resolution will
   be less accurate for such processes.  Grabbing a process with no controlling
   terminal via dtrace -p restores full symbol resolution accuracy for these
   processes, at the cost of dropping breakpoints in them again.  Processes with
   a controlling terminal are still treated as in prior releases.

 - ustack(), usym(), uaddr() and umod() of multithreaded processes no longer
   crashes the system, oopses the kernel, hangs the process being probed,
   crashes dtrace(1) itself, or runs dtrace or the system as a whole out of
   filehandles.

 - Interrupting dtrace with a SIGINT while monitored processes are dying
   simultaneously now consistently stops it rather than hanging forever.

 - dtrace's symbol-resolution paths are armoured against various problems which
   could occur when processes died while lookups were underway.

 - pid and ppid are now correctly derived for multithreaded processes, pointing
   to the POSIX pid and parent respectively rather than the thread and thread
   group leader.

 - Resolving kernel symbols located at the start of modules will no longer
   cause dtrace userspace to dereference uninitialized memory as a pointer.

0.4.1
-----

New features:

 - New development tools showUSDT (for dumping of DOF sections) and
   ctf_module_dump (for dumping of CTF in kernel modules).  (The former tool is
   an example only, and is installed in the documentation directory.)

 - DTrace now automatically modprobes for dtrace.ko if needed, and yum installs
   it if it is not found on the system.  Provider modules are not automatically
   modprobed, but running (for example) dtrace -l is now a good way to make sure
   that the modules are present on the system so you can modprobe them.

Bugfixes:

 - A lexer bug was fixed which caused spurious errors if D scripts contained a
   #pragma or comment at intervals of 8192 characters, and prevented the use
   of scripts >16KiB entirely.
   [Introduced in the original Linux port]

 - A variety of memory leaks and uninitialized memory reads are fixed.

 - A bug whereby breakpoints could be left outstanding in a process if dtrace
   was interrupted with an ordinary SIGINT at just the wrong instant is fixed.
   [Introduced in DTrace 0.4.0.]

 - The visibility of .SUNW_dof sections was wrong.
   [Introduced in DTrace 0.4.0.]

 - Fix devinfo_t's dev_statname and dev_pathname for cases where the
   device does not have partitions.
   [Introduced in DTrace 0.4.0.]

 - drti.o, which contributes a constructor to programs and shared libraries
   that contain DOF, now has lower overhead when DTrace is not running,
   emits its errors to stdout, not stderr, and opens its files with O_CLOEXEC.
   [Introduced in DTrace 0.4.0.]

0.4
---

New features:

 - Symbol lookup now works: stack() and ustack() now print symbols, as does &.
   ustack() can look up symbols in libraries loaded with dlopen() and dlmopen()
   as well as via DT_NEEDED.  Symbol lookup of global symbols in userspace
   processes respects symbol interposition and all other symbol-ordering
   trickery.  Some of the machinery involved in this only works with programs
   running against specific versions of the GNU C Library.  (It will always work
   with the version of glibc shipped with OEL, and falls back to a simpler
   approach which does not support symbol interposition or dlmopen() if it
   appears an incompatible glibc is in use).

   This depends on new machinery in the kernel, notably waitfd()s and
   PTRACE_GETMAPFD, so will not work with earlier DTrace kernels.

 - USDT support: see the dtrace-module NEWS.  A new header file (sys/sdt.h) is
   installed in support of USDT.

 - -xevaltime={preinit, postinit, main} now work, with a few caveats:

   - postinit (the default) is equivalent to main.

   - On statically linked binaries, preinit is equivalent to exec, and may
     not skip ld.so initialization (which can happen after main() on such
     binaries).

   - On stripped, statically linked binaries, postinit and main are equivalent
     to preinit, because we cannot look up the 'main' symbol when there is no
     symbol table.

 - DTrace options can now be set from environment variables named DTRACE_OPT_*.
   Example:

     export DTRACE_OPT_INCDIR=/usr/lib64/dtrace:/usr/include/sys

Changes to user-visible internals:

 - The ELF section in which CTF data is stored has changed from .dtrace_ctf to
   .ctf.

 - The storage representation of internal kernel symbols is improved, saving
   DTrace memory usage at startup by a megabyte or so.

 - The libdtrace public API header now names its arguments.  A few other
   libdtrace functions have changed prototype: see INCOMPATIBILITIES.

 - Two undocumented libproc environment variables from Solaris are removed,
   because the code whose behaviour they adjusted no longer exists:
   _LIBPROC_INCORE_ELF and _LIBPROC_NO_QSORT.

 - New low-overhead debugging machinery.  Exporting DTRACE_DEBUG=signal in the
   environment will emit debugging output only when DTrace is hit by a SIGUSR1,
   avoiding all printf() locking overhead until then.  This uses a ring buffer
   to stop debugging output, by default 100Mb in size, changeable via the
   DTRACE_DEBUG_BUF_SIZE variable (which takes a size in megabytes).

Bugfixes:

 - The -h and -G command-line options work.

 - Negative values passed to DTrace options that take only positive integers are
   correctly diagnosed as errors again.

Known bugs and limitations:

 - Presently, kill -9'ing a running dtrace can leave breakpoints outstanding in
   other processes, which may sooner or later kill them.  This will be fixed in
   due course (by avoiding the use of breakpoints in more cases).

0.3
---

New features:

 - CTF support.  This exposes all kernel types declared at the global scope to
   DTrace scripts (even those private to single files).  All global kernel
   variables not declared static are also available to the ` operator as
   external variables.

   The module for kernel-wide symbols is known as vmlinux, but genunix can
   still be used as a name for it to aid script portability.

   Kernel modules from a compatible kernel must be visible to DTrace for this
   feature to work, as must the kernel-provided file /proc/kallmodsyms.  DTrace
   will work with no kernel modules, with no visible /proc, or with a kernel
   whose modules do not contain type information, but no kernel types or
   variables will be available.  (See -xprocfspath and -xmodpath below.)

New dependencies:

 - DTrace now depends on libdtrace-ctf, a modified, GPLed port of the Solaris
   libctf type-storage library.  Despite its name it cannot read Solaris CTF
   files: the file formats are incompatible.

New options:

 - -xprocfspath: if set, specifies the path to /proc.  May be useful in chroots,
   though glibc and other things may break if /proc is moved to another
   location.

 - -xmodpath: if set, specifies the path to kernel modules, rather than looking
   in /lib/modules/$(uname -r).

Options removed:

 - The undocumented -xlinkmode=primary option is removed: it never worked in
   DTrace for Linux in any case.

Bugfixes:

 - The -c and -p command-line options work.

 - Lexer bugs causing aggressive and unnecessary reading of modules are fixed.
   As a result, when used with typo-free scripts, DTrace now starts much faster
   than ever it did on Solaris (often taking half the time or less).  You may
   find a few error messages have changed error text (though not error tag) as a
   result of this bugfix and the following one.

 - The SDT provider now describes its argument types to DTrace userspace.

 - Supported SDT probes in non-text segments

 - The types of many DTrace actions and variables are fixed to correspond to
   the Linux reality.

 - The set of available error numbers in errno.d is more complete.

 - DTrace libraries are installed to /usr/lib64 now, not /usr/lib.

 - Users of dtrace -C can now #include <sys/dtrace.h> without incident.

Changes to user-visible internals:

 - A new file /proc/kallmodsyms now exists, like /proc/kallsyms but giving
   object sizes and listing the module each kernel object would be part of
   were it built as a module, even if it is currently built in.

 - A new module dtrace_ctf.ko is pulled in whenever dtrace.ko is loaded.
   It is a container for type information.

 - The undocumented -B buffer-inspection command-line option no longer crashes
   DTrace.


0.2.5
-----

New features:

 - libdtrace is now a shared library, just as on OpenSolaris, with a very
   similar API.  No API or ABI compatibility guarantees are made regarding
   this library, at present.


0.2
---

New features:

 - The SDT provider is implemented, providing in-kernel static probes.  Some of
   the proc provider is implemented using this facility.

Bugfixes:

 - Syscall tracing of stub-based syscalls (such as fork, clone, exit, and
   sigreturn) now works.
 - Invalid memory accesses inside D scripts no longer cause oopses or panics.
 - Memory exhaustion inside D scripts no longer emits spurious oopses.
 - Several crash fixes.
 - Fixes to arithmetic inside aggregations, fixing quantize().
 - Improvements to the installed headers.


0.1
---

First release. Working components:

 - the entire D language, with the exception of parts that depend on
   symbol lookup or CTF

 - the syscall provider (with the exception of the clone probe, which
   is disabled)

 - the profile provider (with the exception of arbitrary-precision
   profile timers).

 - kernel stack tracebacks, but ustack() prints addresses only, no symbols

Major components not yet present include all the other providers, including sdt
usdt.
