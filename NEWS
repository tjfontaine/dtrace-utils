0.6.2 (Sep 12th, 2017)
----------------------

Packaging changes:

 - The DTrace headers in /usr/include/linux/dtrace were formerly provided by the
   dtrace-modules-shared-headers package.  They are now pulled in from the
   kernel-uek-devel package in /usr/src/kernels at dtrace-utils package build
   time and shipped out into the dtrace-utils-devel package.

 - libdtrace-ctf 0.7 or above is now required.

 - CTF type information can now be provided in an archive located at
   /lib/modules/$(uname -r)/kernel/vmlinux.ctfa, cutting startup time when all
   types referenced are found in the kernel tree rather than in out-of-tree
   modules.

New features:

 - A new llquantize() aggregation, providing log/linear results.
   Syntax:
     llquantize(expression, log base, lower exponent, upper exponent, step,
                [increment])

 - The tracemem() action has gained a third argument, the number of bytes
   to trace: unlike the second argument, which must be a constant, the
   third argument can be an arbitrary D expression, which can be used
   to limit a larger second argument to a suitable value.  This brings it
   into parity with tracemem() on Solaris.

Bugfixes:

 - dtrace_sync() is drastically faster: setup and teardown of large numbers of
   probes without latency problems and watchdog timer firings is now much
   more practical.

 - The error message given when D argument counts were wrong was itself
   often wrong or confusing.

 - Fixed a segfault at shutdown time if grabbed processes die at precisely
   the wrong time.

 - Structure and union members in the kernel with the same name as D keywords
   can now be referenced: mostly, this means you can get at members named
   'self'.

 - lquantize() no longer truncates its value to 32 bits.

 - dtrace_update() now merges module address ranges better.

 - Fix some places where sleeping inside RCU read critical sections or
   atomic context could happen (module provide, profile/tick providers,
   and more general probe and state setup/teardown code).

 - After one release without it, the walltimestamp variable reports useful
   values again.

 - One place where failure to allocate memory (for ECBs) could crash the kernel
   has been fixed.

Build-time:

 - A new 'make ctf' target in the kernel tree, for generating the vmlinux.ctfa
   archive mentioned above: it is no longer linked into in-tree modules.
   The old CONFIG_DT_DISABLE_CTF option is thus removed, as is the ctf.ko module.

 - You can no longer build CTF as root.

 - Kernel CTF type generation now understands the DWARF generated by GCC 6; one
   more problem with representation of bitfields is fixed; and one sort of
   painfully manually-maintained type-related blacklist is now automated away.

 - Some unused variable warnings in the io provider are squashed.


0.6.1 (Aug 7th, 2017)
---------------------

Licensing changes:

 - Userspace is now licensed under the Universal Permissive License (UPL) v1.0.
   The kernel module is now GPLv2, and is shipped in the same package as other
   in-tree kernel modules.

   /usr/lib64/dtrace/load_dtrace_modules no longer tries to yum install
   anything (but will still modprobe modules listed in /etc/dtrace-modules).

New features:

 - A new link_ntop() subroutine is provided, which is like inet_ntop()
   except it returns a human-readable string describing the link-layer
   address.  Ethernet and InfiniBand are currently supported.

 - A default set of modules is now provided in /etc/dtrace-modules.  The
   file was supported since 0.4.5, but no /etc/dtrace-modules was shipped
   by default.

 - The TCP and UDP providers are implemented, with associated translators.

 - The IO provider has been completely rewritten and is dramatically
   improved, with support for most local filesystems and explicit
   support for XFS and NFS.

Bugfixes:

 - Do not require sdt.ko to be loaded before allowing the use of the 'cpu'
   variable.

 - Passing an object file through dtrace -G no longer corrupts it on
   SPARC64, echoing a similar bugfix made to x86 long ago.

 - Improve tracking of process state on SPARC64 a bit.

 - Bitfields in kernel types are now better-supported, though some
   bitfields still do not work, notably those crossing machine word
   boundaries.

 - dtrace_print_lquantize() no longer normalizes the name of the lowest
   bucket, only the bucket contents (as intended).

 - jstack() was fetching data from the wrong offset, leading to garbage
   output at the start of the stack dump.

 - Reading of unaligned data from high addresses in traced processes
   was failing.  In practice only SPARC has any data at addresses high
   enough to cause this, and most of the accesses done are aligned: but
   the machinery that adjusts to changes in glibc's internal data
   structures was broken, leading to failures to look up symbols after
   certain glibc upgrades.

 - dtrace -C and -G now search for cpp and ld along the PATH rather than
   defaulting to /usr/bin/cpp and /usr/bin/ld, fixing failures with
   compilers in non-default locations, like the Software Collections
   devtoolset packages.

 - dtrace-utils-devel now requires elfutils-libelf-devel.  (This
   dependency was always present in practice but was mistakenly omitted
   until now.)


0.6.0 (Apr 3rd, 2017)
---------------------
Kernel release: 4.1.12-97.el6uek

New features:

 - Function boundary tracing (FBT) is supported for entry probes to most
   functions in the core kernel.  The current implementation does not support
   retrieval of function arguments or return probes (except for some limited
   support on x86_64).  These features are currently under development.

 - The ip provider is implemented, supporting ip:::send, ip:::receive,
   ip:::drop-in and ip:::drop-out, with parameters compatible with other
   implementations and appropriate translators. IPv4 and IPv6 are both
   supported.

 - Userspace tracepoints (USDT) now work on SPARC for both 64- and 32-bit
   processes.

 - The types and translators used by SDT probes are now acquired from the
   DTRACE_PROBE macros in the kernel source.  New probe argument types and
   translations are picked up automatically without needing to change the
   module at all.  perf-event probe argument types are acquired in the
   same way.

 - The DTRACE_PROBEn() macros used for SDT probes have been supplanted by a
   new DTRACE_PROBE() macro which works exactly the same except that you don't
   need to count the arguments any more and misuses (args with no types, etc)
   are diagnosed even when CONFIG_DTRACE is disabled.  Much the same has been
   done for USDT, except that the old numbered USDT macros remain available for
   code that must be compiled with compilers that don't support __VA_ARGS__
   comma elision (such as GCC when in c89/strict-ANSI mode).  This involves
   a new, installed, internal header, /usr/include/sys/sdt_internal.h.

 - is-enabled probes are now supported for SDT: these are expressions which
   always return false unless the specified probe is enabled, generally used
   directly in if statements, and can be used to suppress collection of
   expensive data only needed for probes until the probes that use them are
   enabled:

     if (DTRACE_PROBE_ENABLED(probename)) /* expensive stuff */

   Per-provider wrappers for DTRACE_PROBE_ENABLED() can be used, as with
   DTRACE_PROBE() itself.

 - dtrace consumers (including dtrace(1)) can now grab themselves via -p,
   though symbol resolution is degraded when they do so because they
   cannot stop themselves.  (Previously, such grabs were suppressed but
   the code to do so was buggy and caused dtrace not to terminate if
   dtrace was asked to do a self-grab in conjunction with a -c of
   some other process, even once the other process had terminated.)

 - D translators for the ip provider are now available.

Bugfixes:

 - Due to a logic error in preemption handling, it was possible that code was
   being executed under the assumption that preemption was disabled when in
   fact it was not.

 - Probe processing (probe context) is not re-entrant, yet probes firing as a
   result of processing another probe would cause re-entry into the processing
   core, with often horrible effects.  The processing core has been modified to
   block any re-entry attempt except for ERROR probe processing.  That is a
   deliberate (and acceptable) exception in the DTrace design.

 - The fast path implementation for obtaining the value of the D 'caller'
   variable for sparc64 has been corrected.

 - The implemenation of the D 'stack' action has been made more robust, making
   sure that memory access faults are not fatal.

 - The implementation of the D 'ustack' action has been reworked completely to
   improve stability and accuracy.

 - The number of stack frames to skip has been adjusted to changes in the
   implementation of various providers, ensuring that DTrace related frames
   are skipped as they should.  This makes the D 'stack' action and the D
   'caller' variable values correct.

 - The implementation of the D 'stackdepth' variable could cause memory writes
   beyond the end of the DTrace probe scratch buffer.

 - Numerous dtrace -c/-p and USDT fixes on SPARC systems, with symptoms
   varying from a hanging dtrace and child process to a dtrace that
   runs out of file descriptors.

 - Fix memory and fd leaks when a process monitored with -c or -p exec()s
   frequently.

Changes to user-visible internals:

 - DTrace now uses /proc/$pid/map_files, where available.

 - The implementation of the D 'ustack' action has been moved into the kernel
   proper.  This change was motivated by the need to access page table
   structures directly using a lock-free mechanism.

 - Probe processing will be bypassed when the system is entering panic mode,
   This ensures that DTrace will not cause panic related output to be
   disrupted.

 - dtrace -S now dumps the offset of DIF as well as the instruction counter,
   allowing you to more easily match up DIF disassembly with errors from the
   kernel.

 - Predicate DIF is disassembled in dtrace -S output.


0.5.4 (Nov 8th, 2016)
---------------------

Workarounds:

 - Work around a bug in elfutils causing massive corruption of object files when
   dtrace -G is used.


0.5.3  (May 25th, 2016)
-----------------------
Kernel release: 4.1.12-43.el6uek

New features:

 - It is now possible to have perf-events presented as DTrace SDT probes.
   This feature is turned on by default in the kernel.  The probes will
   appear with the same names as the perf-events and are grouped under the
   new 'perf' SDT provider.

   In its current implementation, the perf-events DTrace probes do not offer
   argument type informtation as is seen with standard DTrace SDT probes.

Bugfixes:

 - On sparc64, it was possible to crash the system by unloading and reloading
   the sdt DTrace multi-provider module due to the handling of memory that is
   set aside for SDT probe trampolines.  This bug has been fixed.

Crash fixes:

 - When dtrace(1) exited at the same instant as a process it had grabbed (e.g.
   for ustack()) terminated, it could deadlock or crash with an assertion
   failure or a segmentation fault.


0.5.2 (Feb 3rd, 2016)
---------------------
Kernel release: 4.1.12-33.el6uek

Crash fixes:

 - Programs containing USDT probes can crash at startup or dlopen() time if
   shared libraries are mapped into the top half of the address space.  This
   never happens on x86-64 but is common on SPARC64: dtrace -G should be
   rerun on programs on such platforms that contain USDT probes, to link in
   the fixed ELF constructor.

Performance improvements:

 - dtrace(1) no longer wastes time in a CPU-heavy busywaiting loop: previously,
   the sleeping code was mistakenly picking a time in the past to sleep to
   roughly half the time

Bugfixes:

 - dtrace -c and -p now work on SPARC64.

 - When both entry and return probes were enabled for a system call, upon
   disabling the first, the function pointer in the system call table got
   reset to its default value even though the 2nd probe might still be
   active.  This could cause race conditions in the state of the system
   call probing.

 - Access to the SPARC64 R_L7 register was consistenly failing due to an
   off-by-one bug.

 - It was possible to read past the beginning of the stack for a user
   process.  The mechanism for reading stack slots also got updated to
   increase efficiency, consistency and reliability across architectures.

 - While reading the stack of a userspace process, the stack bias was not
   being applied for architectures that need it, causing an abundance of
   essentially invalid values to polute the result.


0.5.1 (Nov 17th, 2015)
----------------------
Kernel release: 4.1.12-24.el6uek

Bugfixes:

 - When copyout() or copyoutstr() is used in a D script, safety checks are now
   enforced to protect against unprivileged memory accesses.

 - The DTrace modules package no longer prevents automated kernel RPM removal
   when the install limit is reached.

 - It is now possible to access the envp and argv arrays in the psinfo for a
   task using copyin().  This is the convention across DTrace-capable systems.

Performance improvements:

 - dtrace(1) and libdtrace(1) startup speed is improved, both by avoiding a
   filesystem walk by using the modules.order file to locate available kernel
   modules, and by avoiding loading all kernel modules to resolve possible
   types when unqualified probe names that cannot possibly be C identifiers are
   seen (like 'tick-1sec').  When the disk cache is cold these changes speed up
   startup by on the order of 2x.

Changes to user-visible internals:

  - The DTRACE_DEBUG debugging option could intermingle debugging output in
    limited ways when multiple threads were emitting debugging at once.


0.5.0 (Aug 10th, 2015)
-----------------------
Kernel release: 4.1.4-4.el6uek

New architectures:

 - Linux on SPARC64 is supported with the following providers: dtrace, profile,
   syscall, and SDT.  Userspace tracing doesn't work yet.

 - The uid / gid handling has been updated to accommodate namespace support
   at the kernel level (kuid and kgid).  All uid / gid values reported by
   D subroutines (or obtained from structures) are evaluated based on the
   initial user namespace.

New options:

 - -xuseruid: On non-systemd systems (such as OL6), specify the user ID of
   the first non-system user.  (The default will normally be appropriate.)
   Processes with uids below this, and which appear to truly be daemons, are
   only ptrace()d if explicitly specified via dtrace -p or -c.

 - -xsysslice: On systemd systems (such as OL7), specify the name of the
   system slice.  (The default will almost always be appropriate.)
   Processes in this slice or the root slice are considered crucial system
   daemons and only ptrace()d if explicitly specified, as above.

   The systemd/non-systemd determination is made dynamically, so you can
   switch init systems freely and everything should still work.

Changes to user-visible internals:

 - Translator support for the UEK4 4.1 kernel.

 - Accessing kernel memory under NOFAULT protection now implies NOPF (no
   page fault) as well.  Previously, NOPF was an option that could be set
   in addition to NOFAULT.

 - Debugging output has been improved (to be enabled at compile time).

 - The datatype formerly known as sdt_instr_t has been renamed asm_instr_t.
   The rationale behind this change is that it will be used in code beyond
   the SDT provider and therefore a more generic name is appropriate.

Bugfixes:

 - Symbol resolution in non-ptraceable processes is improved.

 - dtrace -p with an invalid PID now produces a sensible error message.


0.4.6 (Jun 30th, 2015)
----------------------

New dependencies:

 - dtrace-utils-devel now always pulls in the corresponding version of
   dtrace-utils, rather than being satisfied with whatever version is
   installed.
   [Introduced in DTrace 0.3.0.]

 - The DTrace kernel header package was renamed dtrace-modules-shared-headers
   in dtrace-modules 0.4.4; dtrace-utils now follows this renaming.

New options:

 - dtrace -vV now reports information on the released version of dtrace, as well
   as the internal version-control ID of dtrace(1) and libdtrace(1).  (The last
   two should always be the same unless the installation is faulty.)

Bugfixes:

 - Processes that receive SIGTRAP in normal operation now work even when being
   dtraced for a ustack(), etc.  Previously, the SIGTRAP would be ignored.
   [Introduced -- intentionally -- in DTrace 0.4.5, though this case would have
    misbehaved in other ways since 0.4.0.]

 - DTrace no longer loses track of processes that exec() while DTrace is looking
   at their dynamic linker state.

 - DTrace no longer leaves breakpoints lying around in fork()ed processes, but
   properly detaches from them and removes its breakpoints.

 - DTrace no longer considers that it knows the state of the symbol table of
   processes it has since stopped monitoring.

 - DTrace no longer crashes multithreaded processes that do dlopen() /
   dlclose().
   [All introduced in DTrace 0.4.0.]

Library interface changes:

 - #including <dtrace.h> used to fail because of the absence of a
   Solaris-specific header we did not ship.  That header is no longer called
   for.

Changes to user-visible internals:

 - DTrace now loads D libraries (with translators, etc) from directories with a
   name that depends upon the running kernel, so can support multiple kernels
   with the same userspace package.

Known bugs:

 - Multithreaded processes under u{stack,sym,addr,mod}() which do dlopen() in
   threads other than the first may not have accurate symbol resolution for
   symbols introduced by such dlopen()s.


0.4.5  (Jun 17th, 2015)
-----------------------
Kernel release: 3.8.13-87.el6uek

New features:

 - Provider modules are now automatically loaded from /etc/dtrace-modules
   when DTrace initializes for the first time, at the same time as dtrace.ko.
   (Providers that do not come from the dtrace-modules package are not
   automatically 'yum install'ed.)

 - It is now possible to use USDT probes in 32-bit applications on 64-bit
   hosts.

Bugfixes:

 - Fixed a (minor) memory leak problem with the help tracing facility in DTrace.
   Upon loading the dtrace.ko module, a buffer (by default 64K) was being
   allocated, and it was never released.

 - Stack backtraces are more accurate as a result of various fixes to adjust the
   number of frames to skip for specific probes.

 - Datatypes have been adjusted to be more carefully specified after a detailed
   audit in preparation for supporting architectures other than x86_64.

 - The stack depth was being determined by requesting a backtrace to be written
   into a temporary buffer that was being allocated (vmalloc), which posed
   significant problems when probes were executing in a context that does not
   support memory allocations.  The buffer is now obtained from the scratch area
   of memory that DTrace provides for probe processing.

 - It was possible to cause a system crash by passing an invalid pointer to
   d_path().  Due to its implementation, it is not possible to depend on safe
   memory accesses to avoid this.  Instead, the pointer passed as argument must
   be validated prior to calling d_path() in the kernel.

 - Fix intermittent dtrace crash on failure of initial grabs or creations of
   processes (via dtrace -p or -c, or via ustack(), usym(), uaddr(), or umod()).

 - Fix dtrace -S DIF subr names.
   [Introduced in DTrace 0.4.0.]

 - DTrace can now reliably monitor processes that undergo exec() and processes
   that are hit by stopping signals and later resumed.  (Previously, it would
   sometimes lose track of the victim process, sometimes kill it with a SIGTRAP,
   and sometimes crash itself.)  Numerous other subtle bugs and deadlocks in
   this area have been fixed as a side-effect.

 - Fix a sign-extension bug in breakpoint-instruction poking which could cause
   the monitored process to crash.
   [Introduced in DTrace 0.4.0.]

 - DTrace is now more resilient against changes to glibc: many places where
   non-ABI-guaranteed internals of glibc are relied upon now dynamically search
   for the correct field offsets, so are resilient against new fields appearing
   in glibc's internal structures, and against fields changing size.

Library interface changes:

 - The dtrace_proc_*() functions have changed the type they take (it is now a
   small structure passed by value).  See INCOMPATIBILITIES.

   There are still no binary-compatibility guarantees for libdtrace consumers.

Changes to user-visible internals:

 - The code has been restructured to facilitate supporting architectures
   other than x86_64 in future releases.

 - The d_path() D subroutine requires its argument to be a pointer to a
   path struct that corresponds to a file that is known to the current
   task (see bugfixes below).

Known bugs:

 - Processes under u{stack,sym,addr,mod}() cannot receive SIGTRAP.

 - Multithreaded processes under u{stack,sym,addr,mod}() which do dlopen() in
   threads other than the first may crash.


0.4.4 (Mar 12, 2015)
--------------------
Kernel release: 3.8.13-69.el6uek

New options:

 - -xcppargs: Additional arguments to pass to the preprocessor when run over D
    scripts by DTrace.

Bugfixes:

 - The DOF ELF object generated by dtrace -G no longer requires an executable
   stack.

 - Renamed the dtrace-modules-headers package to dtrace-modules-shared-headers
   to work around problems in Yum where a symbol has had both versioned and
   unversioned provides over time.


0.4.3 (May 1st, 2014)
---------------------
Kernel release: 3.8.13-33.el6uek

New features:

 - Timer based profile-* probes (profile provider).  These probes use the
   omni-present cyclic support in the UEK3 kernel (3.8.13-32 and later) to
   fire probes at a speciic frequency/interval on every active CPU.

Bugfixes:

 - Several memory-allocation, underrun and overrun bugs in process handling
   were fixed.  With sufficient ingenuity these may be exploitable by local
   users who can craft and run unusual ELF executables and arrange for dtrace
   to attach to them.

 - The pid and ppid variables were being reported based on the kernel task
   PID, which is not the same as the userspace concept of a PID (for threaded
   applications).  We now pass (more correctly) the thread group id (tgid).

 - Since userspace doesn't know about thread kernel level) pids, we are now
   also passing the tgid in the result of ustack, usym, etc...  We pass the
   tgid in the first slot, and the (kernel) pid in the second slot.

Bugfixes:

 - Major reworking of the dtracce_getufpstack() implementation to handle
   locking, stack detection, and potential page fault while accessing the
   stack of a task.

Known problems:

 - As a result of earlier code changes to ensure that all memory allocation
   requests are checked for failures, the test for auto-resize behaviour of
   the principal buffer allocations results in the dtrace utility aborting
   processing rather than continuing operation with the reduced buffer size.
   This is overall a non-harmful regression that will be addressed in a future
   release.


0.4.2 (Dec 20th, 2013)
----------------------
Kernel release: 3.8.13-22.el6uek

New features:

- SDT probe points in kernel modules are now supported.

 - The 'vtimestamp' D variable has been implemented.

Bugfixes:

 - Kill -9'ing a running dtrace will no longer leave breakpoints outstanding in
   processes with no controlling terminal that were grabbed as a side effect of
   ustack(), usym(), uaddr() or umod); as a side effect, symbol resolution will
   be less accurate for such processes.  Grabbing a process with no controlling
   terminal via dtrace -p restores full symbol resolution accuracy for these
   processes, at the cost of dropping breakpoints in them again.  Processes with
   a controlling terminal are still treated as in prior releases.

 - ustack(), usym(), uaddr() and umod() of multithreaded processes no longer
   crashes the system, oopses the kernel, hangs the process being probed,
   crashes dtrace(1) itself, or runs dtrace or the system as a whole out of
   filehandles.

 - Interrupting dtrace with a SIGINT while monitored processes are dying
   simultaneously now consistently stops it rather than hanging forever.

 - dtrace's symbol-resolution paths are armoured against various problems which
   could occur when processes died while lookups were underway.

 - pid and ppid are now correctly derived for multithreaded processes, pointing
   to the POSIX pid and parent respectively rather than the thread and thread
   group leader.

 - Resolving kernel symbols located at the start of modules will no longer
   cause dtrace userspace to dereference uninitialized memory as a pointer.


0.4.1 (Nov 6th, 2013)
---------------------
Kernel release: 3.8.13-16.2.1.el6uek

New features:

 - DTrace now automatically modprobes for dtrace.ko if needed, and yum installs
   it if it is not found on the system.  Provider modules are not automatically
   modprobed, but running (for example) dtrace -l is now a good way to make sure
   that the modules are present on the system so you can modprobe them.

 - It is no longer permissible to have non-unique provider names within the
   context of a userspace process.  I.e. it is not permissible for the main
   executable and a loaded shared library, or two loaded shared libraries, to
   list the same provider name in their DOF sections.

 - A new cyclic implementation has been included in the UEK3 kernel, replacing
   the more error prone former version.  The modules code has been updated to
   use that new implementation.

 - New development tools showUSDT (for dumping of DOF sections) and
   ctf_module_dump (for dumping of CTF in kernel modules).  (The former tool is
   an example only, and is installed in the documentation directory.)

Bugfixes:

 - A lexer bug was fixed which caused spurious errors if D scripts contained a
   #pragma or comment at intervals of 8192 characters, and prevented the use
   of scripts >16KiB entirely.
   [Introduced in the original Linux port]

 - A variety of memory leaks and uninitialized memory reads are fixed.

 - A bug whereby breakpoints could be left outstanding in a process if dtrace
   was interrupted with an ordinary SIGINT at just the wrong instant is fixed.
   [Introduced in DTrace 0.4.0.]

 - The visibility of .SUNW_dof sections was wrong.
   [Introduced in DTrace 0.4.0.]

 - Fix devinfo_t's dev_statname and dev_pathname for cases where the
   device does not have partitions.
   [Introduced in DTrace 0.4.0.]

 - drti.o, which contributes a constructor to programs and shared libraries
   that contain DOF, now has lower overhead when DTrace is not running,
   emits its errors to stdout, not stderr, and opens its files with O_CLOEXEC.
   [Introduced in DTrace 0.4.0.]

 - Lock ordering problems that were inherited from the original code are fixed.

 - Userspace stack memory accesses are now performed in a safe manner.

 - A race condition between speculative tracing buffer cleaning and destroying
   consumer state has been resolved.

 - A memory leak related to consumer state has been fixed.

 - A provider reference counter calculation problem was resolved.

 - The 'errno' D variable now holds the correct value during syscall:::return
   probe action execution, i.e. 0 if the syscall completed without an error,
   and a valid error code if the syscall failed.


0.4.0 (Sep 20th, 2013)
----------------------
Kernel release: 3.8.13-16.el6uek

New features:

 - Support for meta-providers, such as fasttrap (used for userspace tracing).
   A meta-provider implements a framework to instantiate providers dynamically
   (on demand).

 - Userspace Statically Defined Tracing (USDT) provides support for SDT-alike
   probes in userspace executable and libraries.  Two types of probes are
   available: regular SDT-alike probes, and is-enabled probes.  A new header
   file (sys/sdt.h) is installed in support of USDT.

 - The fasttrap provider has been implemented, although it is currently only
   supporting USDT probes.

 - Symbol lookup now works: stack() and ustack() now print symbols, as does &.
   ustack() can look up symbols in libraries loaded with dlopen() and dlmopen()
   as well as via DT_NEEDED.  Symbol lookup of global symbols in userspace
   processes respects symbol interposition and all other symbol-ordering
   trickery.  Some of the machinery involved in this only works with programs
   running against specific versions of the GNU C Library.  (It will always work
   with the version of glibc shipped with OEL, and falls back to a simpler
   approach which does not support symbol interposition or dlmopen() if it
   appears an incompatible glibc is in use).

   This depends on new machinery in the kernel, notably waitfd()s and
   PTRACE_GETMAPFD, so will not work with earlier DTrace kernels.

 - -xevaltime={preinit, postinit, main} now work, with a few caveats:

   - postinit (the default) is equivalent to main.

   - On statically linked binaries, preinit is equivalent to exec, and may
     not skip ld.so initialization (which can happen after main() on such
     binaries).

   - On stripped, statically linked binaries, postinit and main are equivalent
     to preinit, because we cannot look up the 'main' symbol when there is no
     symbol table.

 - DTrace options can now be set from environment variables named DTRACE_OPT_*.
   Example:

     export DTRACE_OPT_INCDIR=/usr/lib64/dtrace:/usr/include/sys

Changes to user-visible internals:

 - The ELF section in which CTF data is stored has changed from .dtrace_ctf to
   .ctf.

 - The storage representation of internal kernel symbols is improved, saving
   DTrace memory usage at startup by a megabyte or so.

 - The libdtrace public API header now names its arguments.  A few other
   libdtrace functions have changed prototype: see INCOMPATIBILITIES.

 - Two undocumented libproc environment variables from Solaris are removed,
   because the code whose behaviour they adjusted no longer exists:
   _LIBPROC_INCORE_ELF and _LIBPROC_NO_QSORT.

 - New low-overhead debugging machinery.  Exporting DTRACE_DEBUG=signal in the
   environment will emit debugging output only when DTrace is hit by a SIGUSR1,
   avoiding all printf() locking overhead until then.  This uses a ring buffer
   to stop debugging output, by default 100Mb in size, changeable via the
   DTRACE_DEBUG_BUF_SIZE variable (which takes a size in megabytes).

 - What was previously defined as a meta-provider (see 0.2.0 below) is in fact
   better defined as a multi-provider, i.e. a provider framework that handles
   multiple providers that essentially share (the majority of) a single
   implementation, such as SDT where probes are grouped together into providers
   even though they are all provided by the same provider (sdt).

 - The DTrace header files in the kernel proper, the kernel modules, and the
   userspace utility have been restructured to avoid duplication and to offer
   a more consistent and clean design.  This also offers better support for
   custom consumers or other DTrace-related utilities.

 - The systrace provider has been updated to account for changes in the Linux
   kernel (between 2.6.39 and 3.8.13).

Bugfixes:

 - It is now possible to get the correct value for the ERR registers.

 - The ustack() and jstack() actions were not passing the PID correctly as the
   first element in the result array.

 - The ustack() action implementation has been replaced.

 - Several obscure locking problems have been resolved.

 - Correct handling of arg5 through arg9.

 - The -h and -G command-line options work.

 - Negative values passed to DTrace options that take only positive integers are
   correctly diagnosed as errors again.

Known bugs and limitations:

 - Presently, kill -9'ing a running dtrace can leave breakpoints outstanding in
   other processes, which may sooner or later kill them.  This will be fixed in
   due course (by avoiding the use of breakpoints in more cases).


0.3.0 (Sep 14th, 2012)
----------------------
Kernel release: 2.6.39-201.0.1.el6uek

New features:

 - CTF support.  This exposes all kernel types declared at the global scope to
   DTrace scripts (even those private to single files).  All global kernel
   variables not declared static are also available to the ` operator as
   external variables.

   The module for kernel-wide symbols is known as vmlinux, but genunix can
   still be used as a name for it to aid script portability.

   Kernel modules from a compatible kernel must be visible to DTrace for this
   feature to work, as must the kernel-provided file /proc/kallmodsyms.  DTrace
   will work with no kernel modules, with no visible /proc, or with a kernel
   whose modules do not contain type information, but no kernel types or
   variables will be available.  (See -xprocfspath and -xmodpath below.)

 - The curcpu builtin variable has been implemented as a DIF builtin variable
   on Linux, providing a pointer to the CPU info structure for the CPU that is
   currently active.

 - A new DIF subroutine has been implemented: d_path().  This subroutine takes
   a pointer to a path structure as argument, and returns a string representing
   the full pathname for that path.

 - The raise() action has been implemented.  This action allows a D script to
   raise a signal in the current task.

 - The io provider probes has been implemented.  It provides the following SDT
   probes: start, wait-start, wait-done, and done.

 - The proc provider has been implemented.  It provides the following SDT
   probes: create, exec, exec-failure, exit, lwp-create, lwp-exit, lwp-start,
   signal-clear, signal-discard, signal-handle, signal-send, start.

 - The sched provider has been implemented.  It provides the following SDT
   probes: change-pri, dequeue, enqueue, off-cpu, on-cpu, preempt, remain-cpu,
   sleep, surrender, tick, wakeup.

 - Argument mappings have been provided for io, proc, and sched provider
   probes.  This information is used by userspace consumers.

New dependencies:

 - DTrace now depends on libdtrace-ctf, a modified, GPLed port of the Solaris
   libctf type-storage library.  Despite its name it cannot read Solaris CTF
   files: the file formats are incompatible.

New options:

 - -xprocfspath: if set, specifies the path to /proc.  May be useful in chroots,
   though glibc and other things may break if /proc is moved to another
   location.

 - -xmodpath: if set, specifies the path to kernel modules, rather than looking
   in /lib/modules/$(uname -r).

Options removed:

 - The undocumented -xlinkmode=primary option is removed: it never worked in
   DTrace for Linux in any case.

Bugfixes:

 - The -c and -p command-line options work.

 - Lexer bugs causing aggressive and unnecessary reading of modules are fixed.
   As a result, when used with typo-free scripts, DTrace now starts much faster
   than ever it did on Solaris (often taking half the time or less).  You may
   find a few error messages have changed error text (though not error tag) as a
   result of this bugfix and the following one.

 - The SDT provider now describes its argument types to DTrace userspace.

 - The types of many DTrace actions and variables are fixed to correspond to
   the Linux reality.

 - The set of available error numbers in errno.d is more complete.

 - DTrace libraries are installed to /usr/lib64 now, not /usr/lib.

 - Users of dtrace -C can now #include <sys/dtrace.h> without incident.

 - Various DIF builtin variables that were providing a hardcoded value based on
   the init task whenever a probe was executing in interrupt context are now
   providing the actual value from the current task.  In Linux, there is always
   a valid task structure available as 'current'.

 - The numbering of the registers for the x86_64 architecture has been updated
   to match the order of registers pushed onto the stack.

 - It is now possible to get the correct value for the DS, ES, FS, and GS
   registers.

 - SDT probes are now correctly cleaned up when the SDT meta-provider module is
   unloaded from the system.

 - The rw_read_held() DIF subroutine will now verify whether it can safely
   access the passed in argument based on the correct argument datatype.

Changes to user-visible internals:

 - A new file /proc/kallmodsyms now exists, like /proc/kallsyms but giving
   object sizes and listing the module each kernel object would be part of
   were it built as a module, even if it is currently built in.

 - A new module dtrace_ctf.ko is pulled in whenever dtrace.ko is loaded.
   It is a container for type information.

 - The undocumented -B buffer-inspection command-line option no longer crashes
   DTrace.

 - The invalid operand trap logic previously provided to support SDT probes has
   been made more generic to support any probes that wish to utilie this
   facility.

 - The DTrace core module now depends on the core kernel CTF data-module, to
   ensure that when DTrace modules are loaded on the system, CTF data for the
   kernel will be available also.


0.2.5
-----
Userspace release only.

New features:

 - libdtrace is now a shared library, just as on OpenSolaris, with a very
   similar API.  No API or ABI compatibility guarantees are made regarding
   this library, at present.


0.2.4 (Feb 15th, 2012)
----------------------
Kernel release: 2.6.39-101.0.1.el6uek

Bugfixes:

 - Provider modules now use a reference counter to determine whether any of
   their probes are currently enabled.  Whenever the reference counter has a
   value greater than zero, the provider module is referenced to ensure that
   it cannot be unloaded.  Once the counter drops down to zero, the reference
   on the module is released.  This prevents providers from being unloaded
   while some of their probes are still in use (which would typically lead to
   a kernel panic).


0.2.3 (Feb 10th, 2012)
----------------------
Kernel release: 2.6.39-101.0.1.el6uek

Internal changes:

 - The DTrace core has been updated to support 28 DTrace option settings, to
   account for the 'quietresize' option that was added to the userspace dtrace
   consumer utility.

Bugfixes:

 - Various assertions in the DTrace core implementation incorrectly used
   mutex_is_locked() where the test was meant to determine whether the current
   task holds the mutex.  This has been corrected.


0.2.0 (Jan 25th, 2012)
----------------------
Kernel release: 2.6.39-101.0.1.el6uek

This release brings DTrace for Linux to the 2.6.39 kernel, as an upgrade from
the previous release based on 2.6.32.

New features:

 - The DTrace core and provider API now support meta-providers, a framework
   that provides multiple providers using a common implementation.

 - The Statically Defined Tracing (SDT) provider is implemented, providing
   in-kernel static probes.  Some of the proc provider is implemented
   using this facility.

Bugfixes:

 - Syscall tracing of stub-based syscalls (such as fork, clone, exit, and
   sigreturn) now works.
 - Invalid memory accesses inside D scripts no longer cause oopses or panics.
 - Memory exhaustion inside D scripts no longer emits spurious oopses.
 - Several crash fixes.
 - Fixes to arithmetic inside aggregations, fixing quantize().
 - Improvements to the installed headers.

Internal changes:

 - The minimal cyclic implementation has been removed from the DTrace modules
   because it is now provided by an equivalent GPL impementation in the core
   kernel.

 - CPU core information is now maintained at the core kernel level.

 - Kernel and module code can now perform safe memory accesses by setting a
   flag in the CPU core information structure.  If a memory access results in
   a Page Fault or General Protection Fault, the failure will be noted as a CPU
   fault, and execution will continue rather than causing a kernel panic.

 - Functionality that depends on walking the stack (determining stack depth, or
   collecting a backtrace) is now provided by a GPL implementation in the core
   kernel.

 - In the interest of consistency, a pseudo kernel module structure is created
   at the core kernel level, representing the main kernel image.  This module
   structure makes it possible to represent all kernel-level objects equally.
   This structure provides a list of SDT probe locations in the core kernel.


0.1.0 (Oct 20th, 2011)
----------------------
Kernel release: 2.6.32-201.0.4.el6uek

First release. Working components:

 - the entire D language, with the exception of parts that depend on
   symbol lookup or CTF

 - The vast majority of the DTrace core functionality has been implemented,
   providing a nearly complete DIF/DOF implementation (including predicates,
   aggregates, and speculative tracing support), provider API, ioctl interface
   for userspace consumers, and direct probe invocation.

 - BEGIN, END, and ERROR probes (dtrace provider).

 - Syscall entry and return probes (systrace provider), with the exception of
   the clone probe, which is disabled

 - the profile provider (timer-based tick-* probes, no arbitrary-precision
   profile timers).

 - kernel stack tracebacks, but ustack() prints addresses only, no symbols

Major components not yet present include all the other providers, including sdt
usdt.
