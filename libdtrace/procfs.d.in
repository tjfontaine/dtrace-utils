/*
 * Copyright 2012 -- 2015 Oracle, Inc.  All rights reserved.
 */

/*
 * This file defines the standard set of inlines and translators to be made
 * available for all D programs to use to examine process model state.
 */

#pragma D depends_on module vmlinux

typedef struct timestruc {
	time_t tv_sec;
	long tv_nsec;
} timestruc_t;

typedef struct lwpsinfo {
	int pr_flag;			/* lwp flags (DEPRECATED) */
	int pr_lwpid;			/* lwp id */
	uintptr_t pr_addr;		/* internal address of lwp */
	uintptr_t pr_wchan;		/* wait addr for sleeping lwp */
	char pr_stype;			/* sync event type */
	char pr_state;			/* numeric lwp state */
	char pr_sname;			/* printable char for pr_state */
	char pr_nice;			/* nice for cpu usage */
	short pr_syscall;		/* syscall number */
	char pr_oldpri;			/* priority */
	char pr_cpu;			/* CPU usage */
	int pr_pri;			/* priority */
	ushort_t pr_pctcpu;		/* % of recent cpu time */
	ushort_t pr_pad;
	timestruc_t pr_start;		/* lwp start time */
	timestruc_t pr_time;		/* usr+sys cpu time */
	char pr_clname[8];		/* scheduling class name */
	char pr_name[16];		/* name */
	processorid_t pr_onpro;		/* processor last ran on */
	processorid_t pr_bindpro;	/* processor bound to */
	psetid_t pr_bindpset;		/* processor set */
	int pr_lgrp;			/* lwp home lgroup */
	int pr_filler[4];
} lwpsinfo_t;

typedef id_t taskid_t;
typedef id_t projid_t;
typedef id_t poolid_t;
typedef id_t zoneid_t;

/*
 * Translate from the kernel's task_struct structure to a Solaris proc(4)
 * psinfo_t struct.
 * We do not provide support for pr_size, pr_rssize, pr_pctcpu, and pr_pctmem.
 * We also do not fill in pr_lwp (the lwpsinfo_t for the representative LWP)
 * because we do not have the ability to select and stop any representative.
 * Also, for the moment, pr_wstat, pr_time, and pr_ctime are not supported,
 * but these could be supported by DTrace in the future using subroutines.
 * Note that any member added to this translator should also be added to the
 * kthread_t-to-psinfo_t translator, below.
 */
typedef struct psinfo {
	int pr_flag;			/* process flags (DEPRECATED) */
	int pr_nlwp;			/* number of active lwps (Linux: 1) */
	pid_t pr_pid;			/* unique process id */
	pid_t pr_ppid;			/* process id of parent */
	pid_t pr_pgid;			/* pid of process group leader */
	pid_t pr_sid;			/* session id */
	uid_t pr_uid;			/* real user id */
	uid_t pr_euid;			/* effective user id */
	uid_t pr_gid;			/* real group id */
	uid_t pr_egid;			/* effective group id */
	uintptr_t pr_addr;		/* address of process */
	size_t pr_size;			/* size of process image (in KB) */
	size_t pr_rssize;		/* resident set sie (in KB) */
	size_t pr_pad1;
	struct tty_struct *pr_ttydev;	/* controlling tty (or -1) */
	ushort_t pr_pctcpu;		/* % of recent cpu time used */
	ushort_t pr_pctmem;		/* % of recent memory used */
	timestruc_t pr_start;		/* process start time */
	timestruc_t pr_time;		/* usr+sys cpu time for process */
	timestruc_t pr_ctime;		/* usr+sys cpu time for children */
	char pr_fname[16];		/* name of exec'd file */
	char pr_psargs[80];		/* initial chars of arg list */
	int pr_wstat;			/* if zombie, wait() status */
	int pr_argc;			/* initial argument count */
	uintptr_t pr_argv;		/* address of initial arg vector */
	uintptr_t pr_envp;		/* address of initial env vector */
	char pr_dmodel;			/* data model */
	char pr_pad2[3];
	taskid_t pr_taskid;		/* task id */
	projid_t pr_projid;		/* project id */
	int pr_nzomb;			/* number of zombie lwps (Linux: 0) */
	poolid_t pr_poolid;		/* pool id */
	zoneid_t pr_zoneid;		/* zone id */
	id_t pr_contract;		/* process contract */
	int pr_filler[1];
	lwpsinfo_t pr_lwp;
} psinfo_t;

inline char PR_MODEL_ILP32 = 1;
#pragma D binding "1.0" PR_MODEL_ILP32
inline char PR_MODEL_LP64 = 2;
#pragma D binding "1.0" PR_MODEL_LP64

m4_dnl 3.18 and above use kuid_t and kgid_t for uids and gids
define_for_kernel([[[[3.18]],[[3.19]],[[4.0]],[[4.1]],[[4.3]],[[4.4]],[[4.5]],[[4.6]],[[4.7]],[[4.8]],[[4.9]],[[4.10]],[[4.11]]]],[[ugid]],[[$1.val]],[[$1]])m4_dnl
#pragma D binding "1.0" translator
translator psinfo_t < struct task_struct *T > {
	pr_nlwp = 1;
	pr_pid = T->tgid;
	pr_ppid = T->real_parent->tgid;
	pr_pgid = T->group_leader->pids[1].pid->numbers[0].nr;
	pr_sid = T->group_leader->pids[2].pid->numbers[0].nr;
	pr_uid = T->cred->ugid(uid);
	pr_euid = T->cred->ugid(euid);
	pr_gid = T->cred->ugid(gid);
	pr_egid = T->cred->ugid(egid);
	pr_addr = (uintptr_t)T;

	pr_ttydev = T->signal->tty ? T->signal->tty
				   : (struct tty_struct *)-1;

	pr_fname = T->comm;
	pr_psargs = stringof(T->dtrace_psinfo->psargs);
	pr_wstat = 0;
	pr_argc = T->dtrace_psinfo->argc;
	pr_argv = (uintptr_t)T->dtrace_psinfo->argv;
	pr_envp = (uintptr_t)T->dtrace_psinfo->envp;

	pr_dmodel = PR_MODEL_LP64;

	pr_taskid = 0;
	pr_projid = 0;
	pr_nzomb = 0;
	pr_poolid = 0;
	pr_zoneid = 0;
	pr_contract = 0;
};

inline int PR_STOPPED = 0x00000001;
#pragma D binding "1.0" PR_STOPPED
inline int PR_ISTOP = 0x00000002;
#pragma D binding "1.0" PR_ISTOP
inline int PR_DSTOP = 0x00000004;
#pragma D binding "1.0" PR_DSTOP
inline int PR_IDLE = 0x10000000;
#pragma D binding "1.0" PR_IDLE

inline char SSLEEP = 1;
#pragma D binding "1.0" SSLEEP
inline char SRUN = 2;
#pragma D binding "1.0" SRUN
inline char SZOMB = 3;
#pragma D binding "1.0" SZOMB
inline char SSTOP = 4;
#pragma D binding "1.0" SSTOP
inline char SIDL = 5;
#pragma D binding "1.0" SIDL
inline char SONPROC = 6;
#pragma D binding "1.0" SONPROC
inline char SWAIT = 7;
#pragma D binding "1.0" SWAIT

/*
 * Translate from the kernel's task_struct structure to a Solaris proc(4)
 * lwpsinfo_t.
 * We do not provide support for pr_nice, pr_oldpri, pr_cpu, or pr_pctcpu.
 * Also, for the moment, pr_start and pr_time are not supported, but these
 * could be supported by DTrace in the future using subroutines.
 */
m4_dnl 4.9 and above moved on_cpu into the task_struct
#pragma D binding "1.0" translator
translator lwpsinfo_t < struct task_struct *T > {
	pr_flag = (T->state & __TASK_STOPPED) ? PR_STOPPED : 0;
/*
	pr_flag = ((T->t_state == TS_STOPPED) ? (PR_STOPPED |
	    ((!(T->t_schedflag & TS_PSTART)) ? PR_ISTOP : 0)) :
	    ((T->t_proc_flag & TP_PRVSTOP) ? PR_STOPPED | PR_ISTOP : 0)) |
	    ((T == T->t_procp->p_agenttp) ? PR_AGENT : 0) |
	    ((!(T->t_proc_flag & TP_TWAIT)) ? PR_DETACH : 0) |
	    ((T->t_proc_flag & TP_DAEMON) ? PR_DAEMON : 0) |
	    ((T->t_procp->p_pidflag & CLDNOSIGCHLD) ? PR_NOSIGCHLD : 0) |
	    ((T->t_procp->p_pidflag & CLDWAITPID) ? PR_WAITPID : 0) |
	    ((T->t_procp->p_proc_flag & P_PR_FORK) ? PR_FORK : 0) |
	    ((T->t_procp->p_proc_flag & P_PR_RUNLCL) ? PR_RLC : 0) |
	    ((T->t_procp->p_proc_flag & P_PR_KILLCL) ? PR_KLC : 0) |
	    ((T->t_procp->p_proc_flag & P_PR_ASYNC) ? PR_ASYNC : 0) |
	    ((T->t_procp->p_proc_flag & P_PR_BPTADJ) ? PR_BPTADJ : 0) |
	    ((T->t_procp->p_proc_flag & P_PR_PTRACE) ? PR_PTRACE : 0) |
	    ((T->t_procp->p_flag & SMSACCT) ? PR_MSACCT : 0) |
	    ((T->t_procp->p_flag & SMSFORK) ? PR_MSFORK : 0) |
	    ((T->t_procp->p_flag & SVFWAIT) ? PR_VFORKP : 0) |
	    (((T->t_procp->p_flag & SSYS) ||
	    (T->t_procp->p_as == &`kas)) ? PR_ISSYS : 0) |
	    ((T == T->t_cpu->cpu_idle_thread) ? PR_IDLE : 0);
*/

	pr_lwpid = T->pid;
	pr_addr = (uintptr_t)T;
	pr_wchan = NULL;
	pr_stype = 0;

	pr_state = (T->state & TASK_INTERRUPTIBLE) ? SSLEEP :
		   (T->state & TASK_UNINTERRUPTIBLE) ? SSLEEP :
		   (T->state & __TASK_STOPPED) ? SSTOP :
		   (T->state & __TASK_TRACED) ? SSTOP :
		   (T->state & EXIT_ZOMBIE) ? SZOMB :
		   (T->state & EXIT_DEAD) ? SZOMB :
		   (T->state & TASK_DEAD) ? SZOMB :
		   (T->state & TASK_WAKEKILL) ? SWAIT :
		   (T->state & TASK_WAKING) ? SWAIT : SRUN;
	pr_sname = (T->state & TASK_INTERRUPTIBLE) ? 'S' :
		   (T->state & TASK_UNINTERRUPTIBLE) ? 'S' :
		   (T->state & __TASK_STOPPED) ? 'T' :
		   (T->state & __TASK_TRACED) ? 'T' :
		   (T->state & EXIT_ZOMBIE) ? 'Z' :
		   (T->state & EXIT_DEAD) ? 'Z' :
		   (T->state & TASK_DEAD) ? 'Z' :
		   (T->state & TASK_WAKEKILL) ? 'W' :
		   (T->state & TASK_WAKING) ? 'W' : 'R';

	pr_pri = T->prio;
	pr_name = T->comm;
define_for_kernel([[[[4.9]],[[4.10]],[[4.11]]]],[[on_cpu]],
[[if_arch([[x86]],[[T->cpu]])]] m4_dnl
[[if_arch([[sparc]],[[((struct thread_info *)T->stack)->cpu]])]],
[[((struct thread_info *)T->stack)->cpu]])m4_dnl
	pr_onpro = on_cpu;
};

inline psinfo_t *curpsinfo = xlate <psinfo_t *> (curthread);
#pragma D attributes Stable/Stable/Common curpsinfo
#pragma D binding "1.0" curpsinfo

inline lwpsinfo_t *curlwpsinfo = xlate <lwpsinfo_t *> (curthread);
#pragma D attributes Stable/Stable/Common curlwpsinfo
#pragma D binding "1.0" curlwpsinfo

inline string cwd = d_path(&(curthread->fs->pwd));
#pragma D attributes Stable/Stable/Common cwd
#pragma D binding "1.0" cwd

inline string root = d_path(&(curthread->fs->root));
#pragma D attributes Stable/Stable/Common root
#pragma D binding "1.0" root

inline int CLD_EXITED = 1;
#pragma D binding "1.0" CLD_EXITED
inline int CLD_KILLED = 2;
#pragma D binding "1.0" CLD_KILLED
inline int CLD_DUMPED = 3;
#pragma D binding "1.0" CLD_DUMPED
inline int CLD_TRAPPED = 4;
#pragma D binding "1.0" CLD_TRAPPED
inline int CLD_STOPPED = 5;
#pragma D binding "1.0" CLD_STOPPED
inline int CLD_CONTINUED = 6;
#pragma D binding "1.0" CLD_CONTINUED
